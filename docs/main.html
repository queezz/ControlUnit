<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>controlunit.main API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>controlunit.main</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys, datetime, os
import numpy as np
import pandas as pd
from pyqtgraph.Qt import QtCore, QtGui

from controlunit.mainView import UIWindow
from controlunit.worker import MAX6675, ADC, Worker
from controlunit.customTypes import Signals
from controlunit.readsettings import make_datafolders, read_settings
from controlunit import qmsSignal

testmark = &#34;test-&#34;

try:
    from AIO import AIO_32_0RA_IRC as adc
    import pigpio
except:
    print(&#34;no pigpio or AIO&#34;)
    TEST = True

    class pigpio:
        def __init__(self) -&gt; None:
            pass

        def pi(self):
            return 0


MAX_SIZE = 10000  # Maximum displayed points in pyqgraph plot

# debug
# def trap_exc_during_debug(*args):
#     print(args)

# sys.excepthook = trap_exc_during_debug

# must inherit QtCore.QObject in order to use &#39;connect&#39;
class MainWidget(QtCore.QObject, UIWindow):
    DEFAULT_TEMPERATURE = 0
    STEP = 3

    sigAbortWorkers = QtCore.pyqtSignal()

    def __init__(self, app: QtGui.QApplication):
        super(self.__class__, self).__init__()
        self.__app = app
        self.connections()
        self.registerDock.setTemp(self.DEFAULT_TEMPERATURE, &#34;---&#34;)

        QtCore.QThread.currentThread().setObjectName(&#34;main&#34;)

        self.__workers_done = 0
        self.__threads = []
        self.__temp = self.DEFAULT_TEMPERATURE

        self.plaData = None
        self.trigData = None
        self.tData = None
        self.p1Data = None
        self.p2Data = None

        # Define which signals comming from ADC
        # REMOVE
        # self.ADCtypes = [Signals.PLASMA, Signals.PRESSURE1, Signals.PRESSURE2]
        # print(&#39;main __init__:&#39;, Signals.adcSignals)

        # self.graph.removeItem(self.graph.plaPl) # remove Plasma current plot

        # Plot line colors
        self.pens = {
            &#34;Ip&#34;: {&#34;color&#34;: &#34;#8d3de3&#34;, &#34;width&#34;: 2},
            &#34;P1&#34;: {&#34;color&#34;: &#34;#6ac600&#34;, &#34;width&#34;: 2},
            &#34;P2&#34;: {&#34;color&#34;: &#34;#c9004d&#34;, &#34;width&#34;: 2},
            &#34;T&#34;: {&#34;color&#34;: &#34;#5999ff&#34;, &#34;width&#34;: 2},
            &#34;trigger&#34;: {&#34;color&#34;: &#34;#edbc34&#34;, &#34;width&#34;: 2},
        }
        self.valuePlaPlot = self.graph.plaPl.plot(pen=self.pens[&#34;Ip&#34;])
        self.triggerPlot = self.graph.plaPl.plot(pen=self.pens[&#34;trigger&#34;])
        self.valueTPlot = self.graph.tempPl.plot(pen=self.pens[&#34;T&#34;])
        self.valueP1Plot = self.graph.presPl.plot(pen=self.pens[&#34;P1&#34;])
        self.valueP2Plot = self.graph.presPl.plot(pen=self.pens[&#34;P2&#34;])
        self.graph.tempPl.setXLink(self.graph.presPl)
        self.graph.plaPl.setXLink(self.graph.presPl)

        self.graph.presPl.setLogMode(y=True)
        self.graph.presPl.setYRange(-8, 3, 0)
        self.graph.tempPl.setYRange(0, 320, 0)

        self.tWorker = None
        self.adcWorker = None

        make_datafolders()
        self.datapth = read_settings()[&#34;datafolder&#34;]

        self.sampling = read_settings()[&#34;samplingtime&#34;]
        self.__changeScale()

        self.showMain()

    def __changeScale(self):
        &#34;&#34;&#34;Set data window size for plotting
        STEP = 2 from worker
        &#34;&#34;&#34;
        index = self.controlDock.scaleBtn.currentIndex()
        txt = self.controlDock.scaleBtn.currentText()
        val = self.controlDock.sampling_windows[txt]
        if val &gt; 0:
            adcind = -int(val / self.sampling / (self.STEP - 1))
            tind = -int(val / 0.25)
        else:
            adcind = 0
            tind = 0
        self.adcind = adcind
        self.tind = tind

        return
        print(f&#34;{txt}\t{adcind}\t{tind}&#34;)
        try:
            print(self.p1Data.shape)
        except:
            pass
        # self.__scale = ScaleSize.getEnum(index)

    def connections(self):
        self.controlDock.scaleBtn.currentIndexChanged.connect(self.__changeScale)

        self.registerDock.registerBtn.clicked.connect(self.registerTemp)
        self.controlDock.IGmode.currentIndexChanged.connect(self.updateIGmode)
        self.controlDock.IGrange.valueChanged.connect(self.updateIGrange)

        self.controlDock.FullNormSW.clicked.connect(self.fulltonormal)
        self.controlDock.OnOffSW.clicked.connect(self.__onoff)
        self.controlDock.quitBtn.clicked.connect(self.__quit)
        self.controlDock.qmsSigSw.clicked.connect(self.__qmsSignal)

        # Toggle plots for Current, Temperature, and Pressure
        self.scaleDock.togIp.clicked.connect(self.togglePlots)
        self.scaleDock.togT.clicked.connect(self.togglePlots)
        self.scaleDock.togP.clicked.connect(self.togglePlots)

        self.scaleDock.Pmin.valueChanged.connect(self.__updatePScale)
        self.scaleDock.Pmax.valueChanged.connect(self.__updatePScale)
        self.scaleDock.Imin.valueChanged.connect(self.__updateIScale)
        self.scaleDock.Imax.valueChanged.connect(self.__updateIScale)
        self.scaleDock.Tmax.valueChanged.connect(self.__updateTScale)

        self.scaleDock.autoscale.clicked.connect(self.__auto_or_levels)
        self.SettingsDock.setSamplingBtn.clicked.connect(self.__set_sampling)

    def __quit(self):
        &#34;&#34;&#34; terminate app &#34;&#34;&#34;
        self.__app.quit()

    def __onoff(self):
        &#34;&#34;&#34; Start and stop worker threads &#34;&#34;&#34;
        if self.controlDock.OnOffSW.isChecked():
            self.startThreads()
            self.controlDock.quitBtn.setEnabled(False)
        else:
            quit_msg = &#34;Are you sure you want to stop data acquisition?&#34;
            reply = QtGui.QMessageBox.warning(
                self.MainWindow,
                &#34;Message&#34;,
                quit_msg,
                QtGui.QMessageBox.Yes,
                QtGui.QMessageBox.No,
            )
            if reply == QtGui.QMessageBox.Yes:
                self.abortThreads()
                self.controlDock.quitBtn.setEnabled(True)
            else:
                self.controlDock.OnOffSW.setChecked(True)

    def __updatePScale(self):
        &#34;&#34;&#34; Updated plot limits for the Pressure viewgraph &#34;&#34;&#34;
        pmin, pmax = [self.scaleDock.Pmin.value(), self.scaleDock.Pmax.value()]

        # self.graph.presPl.setLogMode(y=True)
        self.graph.presPl.setYRange(pmin, pmax, 0)

    def __updateIScale(self):
        &#34;&#34;&#34; Updated plot limits for the plasma current viewgraph &#34;&#34;&#34;
        imin, imax = [self.scaleDock.Imin.value(), self.scaleDock.Imax.value()]
        self.graph.plaPl.setYRange(imin, imax, 0)

    def __updateTScale(self):
        &#34;&#34;&#34; Updated plot limits for the Temperature viewgraph &#34;&#34;&#34;
        tmax = self.scaleDock.Tmax.value()
        self.graph.tempPl.setYRange(0, tmax, 0)

    def __updateScales(self):
        &#34;&#34;&#34; Update all scales according to spinboxes &#34;&#34;&#34;
        self.__updateIScale()
        self.__updateTScale()
        self.__updatePScale()

    def __autoscale(self):
        &#34;&#34;&#34; Set all plots to autoscale &#34;&#34;&#34;
        # enableAutoRange
        plots = [self.graph.plaPl, self.graph.tempPl, self.graph.presPl]

        # [i.autoRange() for i in plots]
        [i.enableAutoRange() for i in plots]

    def __auto_or_levels(self):
        &#34;&#34;&#34; Change plot scales from full auto to Y axis from settings &#34;&#34;&#34;
        if self.scaleDock.autoscale.isChecked():
            self.__autoscale()
        else:
            self.__updateScales()

    def fulltonormal(self):
        &#34;&#34;&#34; Change from full screen to normal view on click&#34;&#34;&#34;
        if self.controlDock.FullNormSW.isChecked():
            self.MainWindow.showFullScreen()
            self.controlDock.setStretch(*(10, 300))  # minimize control dock width
        else:
            self.MainWindow.showNormal()
            self.controlDock.setStretch(*(10, 300))  # minimize control dock width

    def togglePlots(self):
        &#34;&#34;&#34;Toggle plots
        self.scaleDock.togIp
        self.graph.plaPl
        &#34;&#34;&#34;

        def toggleplot(i, pl, row=0, col=0):
            if i.isChecked():
                try:
                    self.graph.addItem(pl, row=row, col=col)
                except:
                    pass
            else:
                try:
                    self.graph.removeItem(pl)  # remove plot
                except:
                    pass

        items = {
            &#34;Ip&#34;: [self.scaleDock.togIp, self.graph.plaPl, 0, 0],
            &#34;T&#34;: [self.scaleDock.togT, self.graph.tempPl, 1, 0],
            &#34;P&#34;: [self.scaleDock.togP, self.graph.presPl, 2, 0],
        }

        [toggleplot(*items[jj]) for jj in [&#34;Ip&#34;, &#34;T&#34;, &#34;P&#34;]]

    def __qmsSignal(self):
        &#34;&#34;&#34;Experiment indicator, analog output is sent to QMS to sync
        expermint time between recording devices.
        This signal is helpfull to separate experiments (same as shot numbers in fusion)
        &#34;&#34;&#34;
        if not self.controlDock.OnOffSW.isChecked():
            return

        try:
            pi = pigpio.pi()
        except:
            print(&#34;pigpio is not defined&#34;)
            return

        if self.controlDock.qmsSigSw.isChecked():
            self.qmsSigThread = qmsSignal.QMSSignal(pi, self.__app, 1)
            self.qmsSigThread.finished.connect(self.qmsSignalTerminate)
            self.qmsSigThread.start()
            self.adcWorker.setQmsSignal(1)
        else:
            quit_msg = &#34;Stop Experiment Marker?&#34;
            reply = QtGui.QMessageBox.warning(
                self.MainWindow,
                &#34;Message&#34;,
                quit_msg,
                QtGui.QMessageBox.Yes,
                QtGui.QMessageBox.No,
            )
            if reply == QtGui.QMessageBox.Yes:
                # old function: QMSSignal.blink_led
                # self.qmsSigThread = qmsSignal.QMSSignal(pi, self.__app, 2)
                self.qmsSigThread = qmsSignal.QMSSignal(pi, self.__app, 0)
                self.qmsSigThread.finished.connect(self.qmsSignalTerminate)
                self.qmsSigThread.start()
                self.adcWorker.setQmsSignal(0)
            else:
                self.controlDock.qmsSigSw.setChecked(True)

    def qmsSignalTerminate(self):
        self.qmsSigThread.quit()
        self.qmsSigThread.wait()

    # MARK: - Threads
    def startThreads(self):
        &#34;&#34;&#34;Define Workers to run in separate threads.
        2020/03/05: two sensors: ADC and temperatures, hence
        2 threds to read a) temperature, and b) analog signals (P1,P2, Ip)
        &#34;&#34;&#34;
        sensors = [&#34;MAX6675&#34;, &#34;ADC&#34;]
        self.datadict = {i: {} for i in sensors}

        self.logDock.log.append(&#34;starting 2 threads&#34;)

        self.__workers_done = 0

        for thread, worker in self.__threads:
            thread.quit()
            thread.wait()

        self.__threads = []

        now = datetime.datetime.now()
        # make threads from sensor worker classes
        threads = {}

        # MAX6675 therm;ocouple sensor for Membrane temperature with PID
        sensor = &#34;MAX6675&#34;
        threads[sensor] = QtCore.QThread()
        threads[sensor].setObjectName(f&#34;{sensor}&#34;)
        self.tWorker = MAX6675(sensor, self.__app, self.datadict[sensor], now)
        self.tWorker.setTempWorker(self.__temp)

        # Multichannel ADC
        sensor = &#34;ADC&#34;
        threads[sensor] = QtCore.QThread()
        threads[sensor].setObjectName(f&#34;{sensor}&#34;)
        self.adcWorker = ADC(sensor, self.__app, self.datadict[sensor], now)
        mode = self.controlDock.IGmode.currentIndex()
        scale = self.controlDock.IGrange.value()
        self.adcWorker.setPresWorker(mode, scale)

        workers = {i: j for i, j in zip(sensors, [self.tWorker, self.adcWorker])}

        print(&#34;threads started: {}&#34;.format(now))
        self.logDock.progress.append(&#34;threads started: {}&#34;.format(now))

        # start threads
        [self.setThread(workers[s], threads[s], s) for s in sensors]

    def setThread(self, worker: Worker, thread: QtCore.QThread, name: str):
        &#34;&#34;&#34;Setup workers [Dataframe creation]
        - Creates instances of worker
        - Creates connections
        - Creates Pandas Dataframes for data logging
        - Saves empty dataframes to local csv. File name based on date and time
        - starts threads
        - sets initial values for all parameters (zeros)
        &#34;&#34;&#34;

        self.__threads.append((thread, worker))
        worker.moveToThread(thread)

        worker.sigStep.connect(self.onWorkerStep)
        worker.sigDone.connect(self.onWorkerDone)
        worker.sigMsg.connect(self.logDock.log.append)
        self.sigAbortWorkers.connect(worker.abort)

        # temperature
        # [MAX6675 device]
        columns = [&#34;date&#34;, &#34;time&#34;, &#34;P1&#34;, &#34;P2&#34;, &#34;Ip&#34;, &#34;IGmode&#34;, &#34;IGscale&#34;, &#34;QMS_signal&#34;]
        if name == &#34;MAX6675&#34;:
            df = pd.DataFrame(dtype=float, columns=[&#34;time&#34;, &#34;T&#34;, &#34;PresetT&#34;])
            df.to_csv(
                os.path.join(
                    self.datapth,
                    f&#34;{testmark}out_{worker.getStartTime():%Y%m%d_%H%M%S}_temp.csv&#34;,
                ),
                index=False,
            )
        # pressures and current
        # [ADC device]
        elif name == &#34;ADC&#34;:
            df = pd.DataFrame(dtype=object, columns=columns)
            df.to_csv(
                os.path.join(
                    self.datapth,
                    f&#34;{testmark}out_{worker.getStartTime():%Y%m%d_%H%M%S}.csv&#34;,
                ),
                index=False,
            )
        else:
            return

        # creates file at the start, next data
        # in the loop is placed in another file
        # TODO: why not to save filename here, and reuse it later?

        thread.started.connect(worker.start)
        thread.start()

    currentvals = {
        Signals.PLASMA: 0,
        Signals.TEMPERATURE: 0,
        Signals.PRESSURE1: 0,
        Signals.PRESSURE2: 0,
    }

    # Mark: connecting slots with threads
    @QtCore.pyqtSlot(np.ndarray, np.ndarray, np.ndarray, Signals, datetime.datetime)
    def onWorkerStep(self, rawResult, calcResult, ave, ttype, startTime):
        &#34;&#34;&#34;collect data on worker step
        - Recives data from worker(s)
        - Updates text indicators in GUI
        - Appends recived data to dataframes (call to self.__setStepData)
        - Updates data in plots (skips points if data is too big)
        &#34;&#34;&#34;
        # MEMO: ave [[theadtype, average], [], []]
        for l in ave:
            self.currentvals[l[0]] = l[1]
        &#34;&#34;&#34; set Bw text &#34;&#34;&#34;
        temp_now = f&#34;{self.currentvals[Signals.TEMPERATURE]:.0f}&#34;
        self.registerDock.setTempText(self.__temp, temp_now)
        # dd1451b
        txt = f&#34;&#34;&#34;
              &lt;table&gt;
                 &lt;tr&gt;
                  &lt;td&gt;
                  &lt;font size=5 color={self.pens[&#39;P1&#39;][&#39;color&#39;]}&gt;
                    Pd = {self.currentvals[Signals.PRESSURE1]:.1e}
                  &lt;/font&gt;
                  &lt;/td&gt;
                  &lt;td&gt;
                   &lt;font size=5 color={self.pens[&#39;P2&#39;][&#39;color&#39;]}&gt;
                    Pu = {self.currentvals[Signals.PRESSURE2]:.1e}
                   &lt;/font&gt;
                  &lt;/td&gt;
                 &lt;/tr&gt;
                 &lt;tr&gt;
                  &lt;td&gt;
                   &lt;font size=5 color={self.pens[&#39;Ip&#39;][&#39;color&#39;]}&gt;
                    I = {self.currentvals[Signals.PLASMA]:.2f}
                   &lt;/font&gt;
                  &lt;/td&gt;
                 &lt;/tr&gt;
                &lt;/table&gt;
        &#34;&#34;&#34;
        # Update current values
        self.controlDock.valueBw.setText(txt)
        self.controlDock.gaugeT.update_value(self.currentvals[Signals.TEMPERATURE])

        # scale = self.__scale.value
        tind = self.tind  # For MAX6675 Temperature sensor
        scale = self.adcind  # For ADC signals

        if ttype == Signals.TEMPERATURE:
            # get data
            t_data = self.tData
            # set and save data
            self.tData = self.__setStepData(
                t_data, rawResult, calcResult, ttype, startTime
            )
            # plot data
            skip = int((self.tData.shape[0] + MAX_SIZE - 1) / MAX_SIZE)
            self.valueTPlot.setData(
                self.tData[tind::skip, 0], self.tData[tind::skip, 1]
            )
        elif ttype in self.ADCtypes:
            # get data
            pl_data = self.plaData
            p1_data = self.p1Data
            p2_data = self.p2Data
            # Append new data and save
            # Each call saves same data. Clean this up.
            # Make one dataframe pere one sensor.
            # plaData, p1Data, and p2Data must be merged.
            self.plaData = self.__setStepData(
                pl_data, rawResult, calcResult, Signals.PLASMA, startTime
            )
            self.p1Data = self.__setStepData(
                p1_data, rawResult, calcResult, Signals.PRESSURE1, startTime
            )
            self.p2Data = self.__setStepData(
                p2_data, rawResult, calcResult, Signals.PRESSURE2, startTime
            )
            # plot data
            skip = int((self.plaData.shape[0] + MAX_SIZE - 1) / MAX_SIZE)
            self.valuePlaPlot.setData(
                self.plaData[scale::skip, 0], self.plaData[scale::skip, 1]
            )
            # self.triggerPlot.setData()
            self.valueP1Plot.setData(
                self.p1Data[scale::skip, 0], self.p1Data[scale::skip, 1]
            )
            self.valueP2Plot.setData(
                self.p2Data[scale::skip, 0], self.p2Data[scale::skip, 1]
            )
        else:
            return

    def __setStepData(self, data, rawResult, calcResult, ttype, startTime):
        &#34;&#34;&#34;
        - Save raw data
        - Append new data from Worker to the main data arrays
        &#34;&#34;&#34;
        # TODO: save interval
        # Save raw data
        self.__save(rawResult, ttype, startTime)
        if data is None:
            data = np.zeros([self.STEP, 2])
            data[:, 0] = calcResult[:, 0]
            data[:, 1] = calcResult[:, ttype.getIndex()]
        else:
            steps = calcResult.shape[0]
            calcData = np.zeros([steps, 2])
            calcData[:, 0] = calcResult[:, 0]
            calcData[:, 1] = calcResult[:, ttype.getIndex()]
            data = np.concatenate((data, np.array(calcData)))
        return data

    def __save(self, data, ttype, startTime):
        &#34;&#34;&#34;Save sensor data
        - For [both] sensors dumps dataframe into a *.csv via pandas to_csv
        &#34;&#34;&#34;
        if ttype == Signals.TEMPERATURE:
            df = pd.DataFrame(data)
            df.to_csv(
                os.path.join(
                    self.datapth, f&#34;{testmark}out_{startTime:%Y%m%d_%H%M%S}_temp.csv&#34;
                ),
                mode=&#34;a&#34;,
                header=False,
                index=False,
            )
        # TODO: change structure
        # For now to save data only once, a workaround:
        # Save only for one Signal type from ADC signals.
        elif ttype == self.ADCtypes[0]:
            df = pd.DataFrame(data)
            df.to_csv(
                os.path.join(
                    self.datapth, f&#34;{testmark}out_{startTime:%Y%m%d_%H%M%S}.csv&#34;
                ),
                mode=&#34;a&#34;,
                header=False,
                index=False,
            )

    @QtCore.pyqtSlot(int, Signals)
    def onWorkerDone(self, workerId, ttype):
        self.logDock.log.append(&#34;Worker #{} done&#34;.format(workerId))
        self.logDock.progress.append(&#34;-- Signal {} STOPPED&#34;.format(workerId))
        self.__workers_done += 1
        # reset Data
        if ttype == Signals.TEMPERATURE:
            self.tData = None
        elif ttype in self.ADCtypes:
            self.plaData = None
            self.p1Data = None
            self.p2Data = None

        if self.__workers_done == 2:
            # self.abortThreads()   # not necessary
            self.logDock.log.append(&#34;No more plot workers active&#34;)

    @QtCore.pyqtSlot()
    def abortThreads(self):
        self.sigAbortWorkers.emit()
        self.logDock.log.append(&#34;Asking each worker to abort&#34;)
        for thread, worker in self.__threads:
            thread.quit()
            thread.wait()
        self.logDock.log.append(&#34;All threads exited&#34;)

    # MARK: - Methods
    @QtCore.pyqtSlot()
    def registerTemp(self):
        value = self.registerDock.temperatureSB.value()
        self.__temp = value
        temp_now = self.currentvals[Signals.TEMPERATURE]
        self.registerDock.setTemp(self.__temp, f&#34;{temp_now:.0f}&#34;)
        if self.tWorker is not None:
            self.tWorker.setPresetTemp(self.__temp)

    @QtCore.pyqtSlot()
    def updateIGmode(self):
        &#34;&#34;&#34;Update mode of the IG controller:
        Torr and linear
        or
        Pa and log
        &#34;&#34;&#34;
        value = self.controlDock.IGmode.currentIndex()
        if self.adcWorker is not None:
            self.adcWorker.setIGmode(value)

    @QtCore.pyqtSlot()
    def __set_sampling(self):
        &#34;&#34;&#34;Set sampling time for ADC&#34;&#34;&#34;
        txt = self.SettingsDock.samplingCb.currentText()
        value = float(txt.split(&#34; &#34;)[0])
        self.sampling = value
        self.__changeScale()
        if self.adcWorker is not None:
            self.adcWorker.setSampling(value)

    @QtCore.pyqtSlot()
    def updateIGrange(self):
        &#34;&#34;&#34;Update range of the IG controller:
        10^{-3} - 10^{-8} multiplier when in linear mode (Torr)
        &#34;&#34;&#34;
        value = self.controlDock.IGrange.value()
        if self.tWorker is not None:
            self.adcWorker.setIGrange(value)


if __name__ == &#34;__main__&#34;:
    app = QtGui.QApplication([])
    widget = MainWidget(app)

    sys.exit(app.exec_())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="controlunit.main.MainWidget"><code class="flex name class">
<span>class <span class="ident">MainWidget</span></span>
<span>(</span><span>app:Â PyQt5.QtWidgets.QApplication)</span>
</code></dt>
<dd>
<div class="desc"><p>QObject(parent: QObject = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MainWidget(QtCore.QObject, UIWindow):
    DEFAULT_TEMPERATURE = 0
    STEP = 3

    sigAbortWorkers = QtCore.pyqtSignal()

    def __init__(self, app: QtGui.QApplication):
        super(self.__class__, self).__init__()
        self.__app = app
        self.connections()
        self.registerDock.setTemp(self.DEFAULT_TEMPERATURE, &#34;---&#34;)

        QtCore.QThread.currentThread().setObjectName(&#34;main&#34;)

        self.__workers_done = 0
        self.__threads = []
        self.__temp = self.DEFAULT_TEMPERATURE

        self.plaData = None
        self.trigData = None
        self.tData = None
        self.p1Data = None
        self.p2Data = None

        # Define which signals comming from ADC
        # REMOVE
        # self.ADCtypes = [Signals.PLASMA, Signals.PRESSURE1, Signals.PRESSURE2]
        # print(&#39;main __init__:&#39;, Signals.adcSignals)

        # self.graph.removeItem(self.graph.plaPl) # remove Plasma current plot

        # Plot line colors
        self.pens = {
            &#34;Ip&#34;: {&#34;color&#34;: &#34;#8d3de3&#34;, &#34;width&#34;: 2},
            &#34;P1&#34;: {&#34;color&#34;: &#34;#6ac600&#34;, &#34;width&#34;: 2},
            &#34;P2&#34;: {&#34;color&#34;: &#34;#c9004d&#34;, &#34;width&#34;: 2},
            &#34;T&#34;: {&#34;color&#34;: &#34;#5999ff&#34;, &#34;width&#34;: 2},
            &#34;trigger&#34;: {&#34;color&#34;: &#34;#edbc34&#34;, &#34;width&#34;: 2},
        }
        self.valuePlaPlot = self.graph.plaPl.plot(pen=self.pens[&#34;Ip&#34;])
        self.triggerPlot = self.graph.plaPl.plot(pen=self.pens[&#34;trigger&#34;])
        self.valueTPlot = self.graph.tempPl.plot(pen=self.pens[&#34;T&#34;])
        self.valueP1Plot = self.graph.presPl.plot(pen=self.pens[&#34;P1&#34;])
        self.valueP2Plot = self.graph.presPl.plot(pen=self.pens[&#34;P2&#34;])
        self.graph.tempPl.setXLink(self.graph.presPl)
        self.graph.plaPl.setXLink(self.graph.presPl)

        self.graph.presPl.setLogMode(y=True)
        self.graph.presPl.setYRange(-8, 3, 0)
        self.graph.tempPl.setYRange(0, 320, 0)

        self.tWorker = None
        self.adcWorker = None

        make_datafolders()
        self.datapth = read_settings()[&#34;datafolder&#34;]

        self.sampling = read_settings()[&#34;samplingtime&#34;]
        self.__changeScale()

        self.showMain()

    def __changeScale(self):
        &#34;&#34;&#34;Set data window size for plotting
        STEP = 2 from worker
        &#34;&#34;&#34;
        index = self.controlDock.scaleBtn.currentIndex()
        txt = self.controlDock.scaleBtn.currentText()
        val = self.controlDock.sampling_windows[txt]
        if val &gt; 0:
            adcind = -int(val / self.sampling / (self.STEP - 1))
            tind = -int(val / 0.25)
        else:
            adcind = 0
            tind = 0
        self.adcind = adcind
        self.tind = tind

        return
        print(f&#34;{txt}\t{adcind}\t{tind}&#34;)
        try:
            print(self.p1Data.shape)
        except:
            pass
        # self.__scale = ScaleSize.getEnum(index)

    def connections(self):
        self.controlDock.scaleBtn.currentIndexChanged.connect(self.__changeScale)

        self.registerDock.registerBtn.clicked.connect(self.registerTemp)
        self.controlDock.IGmode.currentIndexChanged.connect(self.updateIGmode)
        self.controlDock.IGrange.valueChanged.connect(self.updateIGrange)

        self.controlDock.FullNormSW.clicked.connect(self.fulltonormal)
        self.controlDock.OnOffSW.clicked.connect(self.__onoff)
        self.controlDock.quitBtn.clicked.connect(self.__quit)
        self.controlDock.qmsSigSw.clicked.connect(self.__qmsSignal)

        # Toggle plots for Current, Temperature, and Pressure
        self.scaleDock.togIp.clicked.connect(self.togglePlots)
        self.scaleDock.togT.clicked.connect(self.togglePlots)
        self.scaleDock.togP.clicked.connect(self.togglePlots)

        self.scaleDock.Pmin.valueChanged.connect(self.__updatePScale)
        self.scaleDock.Pmax.valueChanged.connect(self.__updatePScale)
        self.scaleDock.Imin.valueChanged.connect(self.__updateIScale)
        self.scaleDock.Imax.valueChanged.connect(self.__updateIScale)
        self.scaleDock.Tmax.valueChanged.connect(self.__updateTScale)

        self.scaleDock.autoscale.clicked.connect(self.__auto_or_levels)
        self.SettingsDock.setSamplingBtn.clicked.connect(self.__set_sampling)

    def __quit(self):
        &#34;&#34;&#34; terminate app &#34;&#34;&#34;
        self.__app.quit()

    def __onoff(self):
        &#34;&#34;&#34; Start and stop worker threads &#34;&#34;&#34;
        if self.controlDock.OnOffSW.isChecked():
            self.startThreads()
            self.controlDock.quitBtn.setEnabled(False)
        else:
            quit_msg = &#34;Are you sure you want to stop data acquisition?&#34;
            reply = QtGui.QMessageBox.warning(
                self.MainWindow,
                &#34;Message&#34;,
                quit_msg,
                QtGui.QMessageBox.Yes,
                QtGui.QMessageBox.No,
            )
            if reply == QtGui.QMessageBox.Yes:
                self.abortThreads()
                self.controlDock.quitBtn.setEnabled(True)
            else:
                self.controlDock.OnOffSW.setChecked(True)

    def __updatePScale(self):
        &#34;&#34;&#34; Updated plot limits for the Pressure viewgraph &#34;&#34;&#34;
        pmin, pmax = [self.scaleDock.Pmin.value(), self.scaleDock.Pmax.value()]

        # self.graph.presPl.setLogMode(y=True)
        self.graph.presPl.setYRange(pmin, pmax, 0)

    def __updateIScale(self):
        &#34;&#34;&#34; Updated plot limits for the plasma current viewgraph &#34;&#34;&#34;
        imin, imax = [self.scaleDock.Imin.value(), self.scaleDock.Imax.value()]
        self.graph.plaPl.setYRange(imin, imax, 0)

    def __updateTScale(self):
        &#34;&#34;&#34; Updated plot limits for the Temperature viewgraph &#34;&#34;&#34;
        tmax = self.scaleDock.Tmax.value()
        self.graph.tempPl.setYRange(0, tmax, 0)

    def __updateScales(self):
        &#34;&#34;&#34; Update all scales according to spinboxes &#34;&#34;&#34;
        self.__updateIScale()
        self.__updateTScale()
        self.__updatePScale()

    def __autoscale(self):
        &#34;&#34;&#34; Set all plots to autoscale &#34;&#34;&#34;
        # enableAutoRange
        plots = [self.graph.plaPl, self.graph.tempPl, self.graph.presPl]

        # [i.autoRange() for i in plots]
        [i.enableAutoRange() for i in plots]

    def __auto_or_levels(self):
        &#34;&#34;&#34; Change plot scales from full auto to Y axis from settings &#34;&#34;&#34;
        if self.scaleDock.autoscale.isChecked():
            self.__autoscale()
        else:
            self.__updateScales()

    def fulltonormal(self):
        &#34;&#34;&#34; Change from full screen to normal view on click&#34;&#34;&#34;
        if self.controlDock.FullNormSW.isChecked():
            self.MainWindow.showFullScreen()
            self.controlDock.setStretch(*(10, 300))  # minimize control dock width
        else:
            self.MainWindow.showNormal()
            self.controlDock.setStretch(*(10, 300))  # minimize control dock width

    def togglePlots(self):
        &#34;&#34;&#34;Toggle plots
        self.scaleDock.togIp
        self.graph.plaPl
        &#34;&#34;&#34;

        def toggleplot(i, pl, row=0, col=0):
            if i.isChecked():
                try:
                    self.graph.addItem(pl, row=row, col=col)
                except:
                    pass
            else:
                try:
                    self.graph.removeItem(pl)  # remove plot
                except:
                    pass

        items = {
            &#34;Ip&#34;: [self.scaleDock.togIp, self.graph.plaPl, 0, 0],
            &#34;T&#34;: [self.scaleDock.togT, self.graph.tempPl, 1, 0],
            &#34;P&#34;: [self.scaleDock.togP, self.graph.presPl, 2, 0],
        }

        [toggleplot(*items[jj]) for jj in [&#34;Ip&#34;, &#34;T&#34;, &#34;P&#34;]]

    def __qmsSignal(self):
        &#34;&#34;&#34;Experiment indicator, analog output is sent to QMS to sync
        expermint time between recording devices.
        This signal is helpfull to separate experiments (same as shot numbers in fusion)
        &#34;&#34;&#34;
        if not self.controlDock.OnOffSW.isChecked():
            return

        try:
            pi = pigpio.pi()
        except:
            print(&#34;pigpio is not defined&#34;)
            return

        if self.controlDock.qmsSigSw.isChecked():
            self.qmsSigThread = qmsSignal.QMSSignal(pi, self.__app, 1)
            self.qmsSigThread.finished.connect(self.qmsSignalTerminate)
            self.qmsSigThread.start()
            self.adcWorker.setQmsSignal(1)
        else:
            quit_msg = &#34;Stop Experiment Marker?&#34;
            reply = QtGui.QMessageBox.warning(
                self.MainWindow,
                &#34;Message&#34;,
                quit_msg,
                QtGui.QMessageBox.Yes,
                QtGui.QMessageBox.No,
            )
            if reply == QtGui.QMessageBox.Yes:
                # old function: QMSSignal.blink_led
                # self.qmsSigThread = qmsSignal.QMSSignal(pi, self.__app, 2)
                self.qmsSigThread = qmsSignal.QMSSignal(pi, self.__app, 0)
                self.qmsSigThread.finished.connect(self.qmsSignalTerminate)
                self.qmsSigThread.start()
                self.adcWorker.setQmsSignal(0)
            else:
                self.controlDock.qmsSigSw.setChecked(True)

    def qmsSignalTerminate(self):
        self.qmsSigThread.quit()
        self.qmsSigThread.wait()

    # MARK: - Threads
    def startThreads(self):
        &#34;&#34;&#34;Define Workers to run in separate threads.
        2020/03/05: two sensors: ADC and temperatures, hence
        2 threds to read a) temperature, and b) analog signals (P1,P2, Ip)
        &#34;&#34;&#34;
        sensors = [&#34;MAX6675&#34;, &#34;ADC&#34;]
        self.datadict = {i: {} for i in sensors}

        self.logDock.log.append(&#34;starting 2 threads&#34;)

        self.__workers_done = 0

        for thread, worker in self.__threads:
            thread.quit()
            thread.wait()

        self.__threads = []

        now = datetime.datetime.now()
        # make threads from sensor worker classes
        threads = {}

        # MAX6675 therm;ocouple sensor for Membrane temperature with PID
        sensor = &#34;MAX6675&#34;
        threads[sensor] = QtCore.QThread()
        threads[sensor].setObjectName(f&#34;{sensor}&#34;)
        self.tWorker = MAX6675(sensor, self.__app, self.datadict[sensor], now)
        self.tWorker.setTempWorker(self.__temp)

        # Multichannel ADC
        sensor = &#34;ADC&#34;
        threads[sensor] = QtCore.QThread()
        threads[sensor].setObjectName(f&#34;{sensor}&#34;)
        self.adcWorker = ADC(sensor, self.__app, self.datadict[sensor], now)
        mode = self.controlDock.IGmode.currentIndex()
        scale = self.controlDock.IGrange.value()
        self.adcWorker.setPresWorker(mode, scale)

        workers = {i: j for i, j in zip(sensors, [self.tWorker, self.adcWorker])}

        print(&#34;threads started: {}&#34;.format(now))
        self.logDock.progress.append(&#34;threads started: {}&#34;.format(now))

        # start threads
        [self.setThread(workers[s], threads[s], s) for s in sensors]

    def setThread(self, worker: Worker, thread: QtCore.QThread, name: str):
        &#34;&#34;&#34;Setup workers [Dataframe creation]
        - Creates instances of worker
        - Creates connections
        - Creates Pandas Dataframes for data logging
        - Saves empty dataframes to local csv. File name based on date and time
        - starts threads
        - sets initial values for all parameters (zeros)
        &#34;&#34;&#34;

        self.__threads.append((thread, worker))
        worker.moveToThread(thread)

        worker.sigStep.connect(self.onWorkerStep)
        worker.sigDone.connect(self.onWorkerDone)
        worker.sigMsg.connect(self.logDock.log.append)
        self.sigAbortWorkers.connect(worker.abort)

        # temperature
        # [MAX6675 device]
        columns = [&#34;date&#34;, &#34;time&#34;, &#34;P1&#34;, &#34;P2&#34;, &#34;Ip&#34;, &#34;IGmode&#34;, &#34;IGscale&#34;, &#34;QMS_signal&#34;]
        if name == &#34;MAX6675&#34;:
            df = pd.DataFrame(dtype=float, columns=[&#34;time&#34;, &#34;T&#34;, &#34;PresetT&#34;])
            df.to_csv(
                os.path.join(
                    self.datapth,
                    f&#34;{testmark}out_{worker.getStartTime():%Y%m%d_%H%M%S}_temp.csv&#34;,
                ),
                index=False,
            )
        # pressures and current
        # [ADC device]
        elif name == &#34;ADC&#34;:
            df = pd.DataFrame(dtype=object, columns=columns)
            df.to_csv(
                os.path.join(
                    self.datapth,
                    f&#34;{testmark}out_{worker.getStartTime():%Y%m%d_%H%M%S}.csv&#34;,
                ),
                index=False,
            )
        else:
            return

        # creates file at the start, next data
        # in the loop is placed in another file
        # TODO: why not to save filename here, and reuse it later?

        thread.started.connect(worker.start)
        thread.start()

    currentvals = {
        Signals.PLASMA: 0,
        Signals.TEMPERATURE: 0,
        Signals.PRESSURE1: 0,
        Signals.PRESSURE2: 0,
    }

    # Mark: connecting slots with threads
    @QtCore.pyqtSlot(np.ndarray, np.ndarray, np.ndarray, Signals, datetime.datetime)
    def onWorkerStep(self, rawResult, calcResult, ave, ttype, startTime):
        &#34;&#34;&#34;collect data on worker step
        - Recives data from worker(s)
        - Updates text indicators in GUI
        - Appends recived data to dataframes (call to self.__setStepData)
        - Updates data in plots (skips points if data is too big)
        &#34;&#34;&#34;
        # MEMO: ave [[theadtype, average], [], []]
        for l in ave:
            self.currentvals[l[0]] = l[1]
        &#34;&#34;&#34; set Bw text &#34;&#34;&#34;
        temp_now = f&#34;{self.currentvals[Signals.TEMPERATURE]:.0f}&#34;
        self.registerDock.setTempText(self.__temp, temp_now)
        # dd1451b
        txt = f&#34;&#34;&#34;
              &lt;table&gt;
                 &lt;tr&gt;
                  &lt;td&gt;
                  &lt;font size=5 color={self.pens[&#39;P1&#39;][&#39;color&#39;]}&gt;
                    Pd = {self.currentvals[Signals.PRESSURE1]:.1e}
                  &lt;/font&gt;
                  &lt;/td&gt;
                  &lt;td&gt;
                   &lt;font size=5 color={self.pens[&#39;P2&#39;][&#39;color&#39;]}&gt;
                    Pu = {self.currentvals[Signals.PRESSURE2]:.1e}
                   &lt;/font&gt;
                  &lt;/td&gt;
                 &lt;/tr&gt;
                 &lt;tr&gt;
                  &lt;td&gt;
                   &lt;font size=5 color={self.pens[&#39;Ip&#39;][&#39;color&#39;]}&gt;
                    I = {self.currentvals[Signals.PLASMA]:.2f}
                   &lt;/font&gt;
                  &lt;/td&gt;
                 &lt;/tr&gt;
                &lt;/table&gt;
        &#34;&#34;&#34;
        # Update current values
        self.controlDock.valueBw.setText(txt)
        self.controlDock.gaugeT.update_value(self.currentvals[Signals.TEMPERATURE])

        # scale = self.__scale.value
        tind = self.tind  # For MAX6675 Temperature sensor
        scale = self.adcind  # For ADC signals

        if ttype == Signals.TEMPERATURE:
            # get data
            t_data = self.tData
            # set and save data
            self.tData = self.__setStepData(
                t_data, rawResult, calcResult, ttype, startTime
            )
            # plot data
            skip = int((self.tData.shape[0] + MAX_SIZE - 1) / MAX_SIZE)
            self.valueTPlot.setData(
                self.tData[tind::skip, 0], self.tData[tind::skip, 1]
            )
        elif ttype in self.ADCtypes:
            # get data
            pl_data = self.plaData
            p1_data = self.p1Data
            p2_data = self.p2Data
            # Append new data and save
            # Each call saves same data. Clean this up.
            # Make one dataframe pere one sensor.
            # plaData, p1Data, and p2Data must be merged.
            self.plaData = self.__setStepData(
                pl_data, rawResult, calcResult, Signals.PLASMA, startTime
            )
            self.p1Data = self.__setStepData(
                p1_data, rawResult, calcResult, Signals.PRESSURE1, startTime
            )
            self.p2Data = self.__setStepData(
                p2_data, rawResult, calcResult, Signals.PRESSURE2, startTime
            )
            # plot data
            skip = int((self.plaData.shape[0] + MAX_SIZE - 1) / MAX_SIZE)
            self.valuePlaPlot.setData(
                self.plaData[scale::skip, 0], self.plaData[scale::skip, 1]
            )
            # self.triggerPlot.setData()
            self.valueP1Plot.setData(
                self.p1Data[scale::skip, 0], self.p1Data[scale::skip, 1]
            )
            self.valueP2Plot.setData(
                self.p2Data[scale::skip, 0], self.p2Data[scale::skip, 1]
            )
        else:
            return

    def __setStepData(self, data, rawResult, calcResult, ttype, startTime):
        &#34;&#34;&#34;
        - Save raw data
        - Append new data from Worker to the main data arrays
        &#34;&#34;&#34;
        # TODO: save interval
        # Save raw data
        self.__save(rawResult, ttype, startTime)
        if data is None:
            data = np.zeros([self.STEP, 2])
            data[:, 0] = calcResult[:, 0]
            data[:, 1] = calcResult[:, ttype.getIndex()]
        else:
            steps = calcResult.shape[0]
            calcData = np.zeros([steps, 2])
            calcData[:, 0] = calcResult[:, 0]
            calcData[:, 1] = calcResult[:, ttype.getIndex()]
            data = np.concatenate((data, np.array(calcData)))
        return data

    def __save(self, data, ttype, startTime):
        &#34;&#34;&#34;Save sensor data
        - For [both] sensors dumps dataframe into a *.csv via pandas to_csv
        &#34;&#34;&#34;
        if ttype == Signals.TEMPERATURE:
            df = pd.DataFrame(data)
            df.to_csv(
                os.path.join(
                    self.datapth, f&#34;{testmark}out_{startTime:%Y%m%d_%H%M%S}_temp.csv&#34;
                ),
                mode=&#34;a&#34;,
                header=False,
                index=False,
            )
        # TODO: change structure
        # For now to save data only once, a workaround:
        # Save only for one Signal type from ADC signals.
        elif ttype == self.ADCtypes[0]:
            df = pd.DataFrame(data)
            df.to_csv(
                os.path.join(
                    self.datapth, f&#34;{testmark}out_{startTime:%Y%m%d_%H%M%S}.csv&#34;
                ),
                mode=&#34;a&#34;,
                header=False,
                index=False,
            )

    @QtCore.pyqtSlot(int, Signals)
    def onWorkerDone(self, workerId, ttype):
        self.logDock.log.append(&#34;Worker #{} done&#34;.format(workerId))
        self.logDock.progress.append(&#34;-- Signal {} STOPPED&#34;.format(workerId))
        self.__workers_done += 1
        # reset Data
        if ttype == Signals.TEMPERATURE:
            self.tData = None
        elif ttype in self.ADCtypes:
            self.plaData = None
            self.p1Data = None
            self.p2Data = None

        if self.__workers_done == 2:
            # self.abortThreads()   # not necessary
            self.logDock.log.append(&#34;No more plot workers active&#34;)

    @QtCore.pyqtSlot()
    def abortThreads(self):
        self.sigAbortWorkers.emit()
        self.logDock.log.append(&#34;Asking each worker to abort&#34;)
        for thread, worker in self.__threads:
            thread.quit()
            thread.wait()
        self.logDock.log.append(&#34;All threads exited&#34;)

    # MARK: - Methods
    @QtCore.pyqtSlot()
    def registerTemp(self):
        value = self.registerDock.temperatureSB.value()
        self.__temp = value
        temp_now = self.currentvals[Signals.TEMPERATURE]
        self.registerDock.setTemp(self.__temp, f&#34;{temp_now:.0f}&#34;)
        if self.tWorker is not None:
            self.tWorker.setPresetTemp(self.__temp)

    @QtCore.pyqtSlot()
    def updateIGmode(self):
        &#34;&#34;&#34;Update mode of the IG controller:
        Torr and linear
        or
        Pa and log
        &#34;&#34;&#34;
        value = self.controlDock.IGmode.currentIndex()
        if self.adcWorker is not None:
            self.adcWorker.setIGmode(value)

    @QtCore.pyqtSlot()
    def __set_sampling(self):
        &#34;&#34;&#34;Set sampling time for ADC&#34;&#34;&#34;
        txt = self.SettingsDock.samplingCb.currentText()
        value = float(txt.split(&#34; &#34;)[0])
        self.sampling = value
        self.__changeScale()
        if self.adcWorker is not None:
            self.adcWorker.setSampling(value)

    @QtCore.pyqtSlot()
    def updateIGrange(self):
        &#34;&#34;&#34;Update range of the IG controller:
        10^{-3} - 10^{-8} multiplier when in linear mode (Torr)
        &#34;&#34;&#34;
        value = self.controlDock.IGrange.value()
        if self.tWorker is not None:
            self.adcWorker.setIGrange(value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
<li><a title="controlunit.mainView.UIWindow" href="mainView.html#controlunit.mainView.UIWindow">UIWindow</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="controlunit.main.MainWidget.DEFAULT_TEMPERATURE"><code class="name">var <span class="ident">DEFAULT_TEMPERATURE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="controlunit.main.MainWidget.STEP"><code class="name">var <span class="ident">STEP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="controlunit.main.MainWidget.currentvals"><code class="name">var <span class="ident">currentvals</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="controlunit.main.MainWidget.abortThreads"><code class="name flex">
<span>def <span class="ident">abortThreads</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@QtCore.pyqtSlot()
def abortThreads(self):
    self.sigAbortWorkers.emit()
    self.logDock.log.append(&#34;Asking each worker to abort&#34;)
    for thread, worker in self.__threads:
        thread.quit()
        thread.wait()
    self.logDock.log.append(&#34;All threads exited&#34;)</code></pre>
</details>
</dd>
<dt id="controlunit.main.MainWidget.connections"><code class="name flex">
<span>def <span class="ident">connections</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connections(self):
    self.controlDock.scaleBtn.currentIndexChanged.connect(self.__changeScale)

    self.registerDock.registerBtn.clicked.connect(self.registerTemp)
    self.controlDock.IGmode.currentIndexChanged.connect(self.updateIGmode)
    self.controlDock.IGrange.valueChanged.connect(self.updateIGrange)

    self.controlDock.FullNormSW.clicked.connect(self.fulltonormal)
    self.controlDock.OnOffSW.clicked.connect(self.__onoff)
    self.controlDock.quitBtn.clicked.connect(self.__quit)
    self.controlDock.qmsSigSw.clicked.connect(self.__qmsSignal)

    # Toggle plots for Current, Temperature, and Pressure
    self.scaleDock.togIp.clicked.connect(self.togglePlots)
    self.scaleDock.togT.clicked.connect(self.togglePlots)
    self.scaleDock.togP.clicked.connect(self.togglePlots)

    self.scaleDock.Pmin.valueChanged.connect(self.__updatePScale)
    self.scaleDock.Pmax.valueChanged.connect(self.__updatePScale)
    self.scaleDock.Imin.valueChanged.connect(self.__updateIScale)
    self.scaleDock.Imax.valueChanged.connect(self.__updateIScale)
    self.scaleDock.Tmax.valueChanged.connect(self.__updateTScale)

    self.scaleDock.autoscale.clicked.connect(self.__auto_or_levels)
    self.SettingsDock.setSamplingBtn.clicked.connect(self.__set_sampling)</code></pre>
</details>
</dd>
<dt id="controlunit.main.MainWidget.fulltonormal"><code class="name flex">
<span>def <span class="ident">fulltonormal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Change from full screen to normal view on click</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fulltonormal(self):
    &#34;&#34;&#34; Change from full screen to normal view on click&#34;&#34;&#34;
    if self.controlDock.FullNormSW.isChecked():
        self.MainWindow.showFullScreen()
        self.controlDock.setStretch(*(10, 300))  # minimize control dock width
    else:
        self.MainWindow.showNormal()
        self.controlDock.setStretch(*(10, 300))  # minimize control dock width</code></pre>
</details>
</dd>
<dt id="controlunit.main.MainWidget.onWorkerDone"><code class="name flex">
<span>def <span class="ident">onWorkerDone</span></span>(<span>self, workerId, ttype)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@QtCore.pyqtSlot(int, Signals)
def onWorkerDone(self, workerId, ttype):
    self.logDock.log.append(&#34;Worker #{} done&#34;.format(workerId))
    self.logDock.progress.append(&#34;-- Signal {} STOPPED&#34;.format(workerId))
    self.__workers_done += 1
    # reset Data
    if ttype == Signals.TEMPERATURE:
        self.tData = None
    elif ttype in self.ADCtypes:
        self.plaData = None
        self.p1Data = None
        self.p2Data = None

    if self.__workers_done == 2:
        # self.abortThreads()   # not necessary
        self.logDock.log.append(&#34;No more plot workers active&#34;)</code></pre>
</details>
</dd>
<dt id="controlunit.main.MainWidget.onWorkerStep"><code class="name flex">
<span>def <span class="ident">onWorkerStep</span></span>(<span>self, rawResult, calcResult, ave, ttype, startTime)</span>
</code></dt>
<dd>
<div class="desc"><p>collect data on worker step
- Recives data from worker(s)
- Updates text indicators in GUI
- Appends recived data to dataframes (call to self.__setStepData)
- Updates data in plots (skips points if data is too big)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@QtCore.pyqtSlot(np.ndarray, np.ndarray, np.ndarray, Signals, datetime.datetime)
def onWorkerStep(self, rawResult, calcResult, ave, ttype, startTime):
    &#34;&#34;&#34;collect data on worker step
    - Recives data from worker(s)
    - Updates text indicators in GUI
    - Appends recived data to dataframes (call to self.__setStepData)
    - Updates data in plots (skips points if data is too big)
    &#34;&#34;&#34;
    # MEMO: ave [[theadtype, average], [], []]
    for l in ave:
        self.currentvals[l[0]] = l[1]
    &#34;&#34;&#34; set Bw text &#34;&#34;&#34;
    temp_now = f&#34;{self.currentvals[Signals.TEMPERATURE]:.0f}&#34;
    self.registerDock.setTempText(self.__temp, temp_now)
    # dd1451b
    txt = f&#34;&#34;&#34;
          &lt;table&gt;
             &lt;tr&gt;
              &lt;td&gt;
              &lt;font size=5 color={self.pens[&#39;P1&#39;][&#39;color&#39;]}&gt;
                Pd = {self.currentvals[Signals.PRESSURE1]:.1e}
              &lt;/font&gt;
              &lt;/td&gt;
              &lt;td&gt;
               &lt;font size=5 color={self.pens[&#39;P2&#39;][&#39;color&#39;]}&gt;
                Pu = {self.currentvals[Signals.PRESSURE2]:.1e}
               &lt;/font&gt;
              &lt;/td&gt;
             &lt;/tr&gt;
             &lt;tr&gt;
              &lt;td&gt;
               &lt;font size=5 color={self.pens[&#39;Ip&#39;][&#39;color&#39;]}&gt;
                I = {self.currentvals[Signals.PLASMA]:.2f}
               &lt;/font&gt;
              &lt;/td&gt;
             &lt;/tr&gt;
            &lt;/table&gt;
    &#34;&#34;&#34;
    # Update current values
    self.controlDock.valueBw.setText(txt)
    self.controlDock.gaugeT.update_value(self.currentvals[Signals.TEMPERATURE])

    # scale = self.__scale.value
    tind = self.tind  # For MAX6675 Temperature sensor
    scale = self.adcind  # For ADC signals

    if ttype == Signals.TEMPERATURE:
        # get data
        t_data = self.tData
        # set and save data
        self.tData = self.__setStepData(
            t_data, rawResult, calcResult, ttype, startTime
        )
        # plot data
        skip = int((self.tData.shape[0] + MAX_SIZE - 1) / MAX_SIZE)
        self.valueTPlot.setData(
            self.tData[tind::skip, 0], self.tData[tind::skip, 1]
        )
    elif ttype in self.ADCtypes:
        # get data
        pl_data = self.plaData
        p1_data = self.p1Data
        p2_data = self.p2Data
        # Append new data and save
        # Each call saves same data. Clean this up.
        # Make one dataframe pere one sensor.
        # plaData, p1Data, and p2Data must be merged.
        self.plaData = self.__setStepData(
            pl_data, rawResult, calcResult, Signals.PLASMA, startTime
        )
        self.p1Data = self.__setStepData(
            p1_data, rawResult, calcResult, Signals.PRESSURE1, startTime
        )
        self.p2Data = self.__setStepData(
            p2_data, rawResult, calcResult, Signals.PRESSURE2, startTime
        )
        # plot data
        skip = int((self.plaData.shape[0] + MAX_SIZE - 1) / MAX_SIZE)
        self.valuePlaPlot.setData(
            self.plaData[scale::skip, 0], self.plaData[scale::skip, 1]
        )
        # self.triggerPlot.setData()
        self.valueP1Plot.setData(
            self.p1Data[scale::skip, 0], self.p1Data[scale::skip, 1]
        )
        self.valueP2Plot.setData(
            self.p2Data[scale::skip, 0], self.p2Data[scale::skip, 1]
        )
    else:
        return</code></pre>
</details>
</dd>
<dt id="controlunit.main.MainWidget.qmsSignalTerminate"><code class="name flex">
<span>def <span class="ident">qmsSignalTerminate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def qmsSignalTerminate(self):
    self.qmsSigThread.quit()
    self.qmsSigThread.wait()</code></pre>
</details>
</dd>
<dt id="controlunit.main.MainWidget.registerTemp"><code class="name flex">
<span>def <span class="ident">registerTemp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@QtCore.pyqtSlot()
def registerTemp(self):
    value = self.registerDock.temperatureSB.value()
    self.__temp = value
    temp_now = self.currentvals[Signals.TEMPERATURE]
    self.registerDock.setTemp(self.__temp, f&#34;{temp_now:.0f}&#34;)
    if self.tWorker is not None:
        self.tWorker.setPresetTemp(self.__temp)</code></pre>
</details>
</dd>
<dt id="controlunit.main.MainWidget.setThread"><code class="name flex">
<span>def <span class="ident">setThread</span></span>(<span>self, worker:Â <a title="controlunit.worker.Worker" href="worker.html#controlunit.worker.Worker">Worker</a>, thread:Â PyQt5.QtCore.QThread, name:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Setup workers [Dataframe creation]
- Creates instances of worker
- Creates connections
- Creates Pandas Dataframes for data logging
- Saves empty dataframes to local csv. File name based on date and time
- starts threads
- sets initial values for all parameters (zeros)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setThread(self, worker: Worker, thread: QtCore.QThread, name: str):
    &#34;&#34;&#34;Setup workers [Dataframe creation]
    - Creates instances of worker
    - Creates connections
    - Creates Pandas Dataframes for data logging
    - Saves empty dataframes to local csv. File name based on date and time
    - starts threads
    - sets initial values for all parameters (zeros)
    &#34;&#34;&#34;

    self.__threads.append((thread, worker))
    worker.moveToThread(thread)

    worker.sigStep.connect(self.onWorkerStep)
    worker.sigDone.connect(self.onWorkerDone)
    worker.sigMsg.connect(self.logDock.log.append)
    self.sigAbortWorkers.connect(worker.abort)

    # temperature
    # [MAX6675 device]
    columns = [&#34;date&#34;, &#34;time&#34;, &#34;P1&#34;, &#34;P2&#34;, &#34;Ip&#34;, &#34;IGmode&#34;, &#34;IGscale&#34;, &#34;QMS_signal&#34;]
    if name == &#34;MAX6675&#34;:
        df = pd.DataFrame(dtype=float, columns=[&#34;time&#34;, &#34;T&#34;, &#34;PresetT&#34;])
        df.to_csv(
            os.path.join(
                self.datapth,
                f&#34;{testmark}out_{worker.getStartTime():%Y%m%d_%H%M%S}_temp.csv&#34;,
            ),
            index=False,
        )
    # pressures and current
    # [ADC device]
    elif name == &#34;ADC&#34;:
        df = pd.DataFrame(dtype=object, columns=columns)
        df.to_csv(
            os.path.join(
                self.datapth,
                f&#34;{testmark}out_{worker.getStartTime():%Y%m%d_%H%M%S}.csv&#34;,
            ),
            index=False,
        )
    else:
        return

    # creates file at the start, next data
    # in the loop is placed in another file
    # TODO: why not to save filename here, and reuse it later?

    thread.started.connect(worker.start)
    thread.start()</code></pre>
</details>
</dd>
<dt id="controlunit.main.MainWidget.sigAbortWorkers"><code class="name flex">
<span>def <span class="ident">sigAbortWorkers</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="controlunit.main.MainWidget.startThreads"><code class="name flex">
<span>def <span class="ident">startThreads</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Define Workers to run in separate threads.
2020/03/05: two sensors: ADC and temperatures, hence
2 threds to read a) temperature, and b) analog signals (P1,P2, Ip)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startThreads(self):
    &#34;&#34;&#34;Define Workers to run in separate threads.
    2020/03/05: two sensors: ADC and temperatures, hence
    2 threds to read a) temperature, and b) analog signals (P1,P2, Ip)
    &#34;&#34;&#34;
    sensors = [&#34;MAX6675&#34;, &#34;ADC&#34;]
    self.datadict = {i: {} for i in sensors}

    self.logDock.log.append(&#34;starting 2 threads&#34;)

    self.__workers_done = 0

    for thread, worker in self.__threads:
        thread.quit()
        thread.wait()

    self.__threads = []

    now = datetime.datetime.now()
    # make threads from sensor worker classes
    threads = {}

    # MAX6675 therm;ocouple sensor for Membrane temperature with PID
    sensor = &#34;MAX6675&#34;
    threads[sensor] = QtCore.QThread()
    threads[sensor].setObjectName(f&#34;{sensor}&#34;)
    self.tWorker = MAX6675(sensor, self.__app, self.datadict[sensor], now)
    self.tWorker.setTempWorker(self.__temp)

    # Multichannel ADC
    sensor = &#34;ADC&#34;
    threads[sensor] = QtCore.QThread()
    threads[sensor].setObjectName(f&#34;{sensor}&#34;)
    self.adcWorker = ADC(sensor, self.__app, self.datadict[sensor], now)
    mode = self.controlDock.IGmode.currentIndex()
    scale = self.controlDock.IGrange.value()
    self.adcWorker.setPresWorker(mode, scale)

    workers = {i: j for i, j in zip(sensors, [self.tWorker, self.adcWorker])}

    print(&#34;threads started: {}&#34;.format(now))
    self.logDock.progress.append(&#34;threads started: {}&#34;.format(now))

    # start threads
    [self.setThread(workers[s], threads[s], s) for s in sensors]</code></pre>
</details>
</dd>
<dt id="controlunit.main.MainWidget.togglePlots"><code class="name flex">
<span>def <span class="ident">togglePlots</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Toggle plots
self.scaleDock.togIp
self.graph.plaPl</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def togglePlots(self):
    &#34;&#34;&#34;Toggle plots
    self.scaleDock.togIp
    self.graph.plaPl
    &#34;&#34;&#34;

    def toggleplot(i, pl, row=0, col=0):
        if i.isChecked():
            try:
                self.graph.addItem(pl, row=row, col=col)
            except:
                pass
        else:
            try:
                self.graph.removeItem(pl)  # remove plot
            except:
                pass

    items = {
        &#34;Ip&#34;: [self.scaleDock.togIp, self.graph.plaPl, 0, 0],
        &#34;T&#34;: [self.scaleDock.togT, self.graph.tempPl, 1, 0],
        &#34;P&#34;: [self.scaleDock.togP, self.graph.presPl, 2, 0],
    }

    [toggleplot(*items[jj]) for jj in [&#34;Ip&#34;, &#34;T&#34;, &#34;P&#34;]]</code></pre>
</details>
</dd>
<dt id="controlunit.main.MainWidget.updateIGmode"><code class="name flex">
<span>def <span class="ident">updateIGmode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update mode of the IG controller:
Torr and linear
or
Pa and log</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@QtCore.pyqtSlot()
def updateIGmode(self):
    &#34;&#34;&#34;Update mode of the IG controller:
    Torr and linear
    or
    Pa and log
    &#34;&#34;&#34;
    value = self.controlDock.IGmode.currentIndex()
    if self.adcWorker is not None:
        self.adcWorker.setIGmode(value)</code></pre>
</details>
</dd>
<dt id="controlunit.main.MainWidget.updateIGrange"><code class="name flex">
<span>def <span class="ident">updateIGrange</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update range of the IG controller:
10^{-3} - 10^{-8} multiplier when in linear mode (Torr)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@QtCore.pyqtSlot()
def updateIGrange(self):
    &#34;&#34;&#34;Update range of the IG controller:
    10^{-3} - 10^{-8} multiplier when in linear mode (Torr)
    &#34;&#34;&#34;
    value = self.controlDock.IGrange.value()
    if self.tWorker is not None:
        self.adcWorker.setIGrange(value)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="controlunit.main.pigpio"><code class="flex name class">
<span>class <span class="ident">pigpio</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class pigpio:
    def __init__(self) -&gt; None:
        pass

    def pi(self):
        return 0</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="controlunit.main.pigpio.pi"><code class="name flex">
<span>def <span class="ident">pi</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pi(self):
    return 0</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="controlunit" href="index.html">controlunit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="controlunit.main.MainWidget" href="#controlunit.main.MainWidget">MainWidget</a></code></h4>
<ul class="two-column">
<li><code><a title="controlunit.main.MainWidget.DEFAULT_TEMPERATURE" href="#controlunit.main.MainWidget.DEFAULT_TEMPERATURE">DEFAULT_TEMPERATURE</a></code></li>
<li><code><a title="controlunit.main.MainWidget.STEP" href="#controlunit.main.MainWidget.STEP">STEP</a></code></li>
<li><code><a title="controlunit.main.MainWidget.abortThreads" href="#controlunit.main.MainWidget.abortThreads">abortThreads</a></code></li>
<li><code><a title="controlunit.main.MainWidget.connections" href="#controlunit.main.MainWidget.connections">connections</a></code></li>
<li><code><a title="controlunit.main.MainWidget.currentvals" href="#controlunit.main.MainWidget.currentvals">currentvals</a></code></li>
<li><code><a title="controlunit.main.MainWidget.fulltonormal" href="#controlunit.main.MainWidget.fulltonormal">fulltonormal</a></code></li>
<li><code><a title="controlunit.main.MainWidget.onWorkerDone" href="#controlunit.main.MainWidget.onWorkerDone">onWorkerDone</a></code></li>
<li><code><a title="controlunit.main.MainWidget.onWorkerStep" href="#controlunit.main.MainWidget.onWorkerStep">onWorkerStep</a></code></li>
<li><code><a title="controlunit.main.MainWidget.qmsSignalTerminate" href="#controlunit.main.MainWidget.qmsSignalTerminate">qmsSignalTerminate</a></code></li>
<li><code><a title="controlunit.main.MainWidget.registerTemp" href="#controlunit.main.MainWidget.registerTemp">registerTemp</a></code></li>
<li><code><a title="controlunit.main.MainWidget.setThread" href="#controlunit.main.MainWidget.setThread">setThread</a></code></li>
<li><code><a title="controlunit.main.MainWidget.sigAbortWorkers" href="#controlunit.main.MainWidget.sigAbortWorkers">sigAbortWorkers</a></code></li>
<li><code><a title="controlunit.main.MainWidget.startThreads" href="#controlunit.main.MainWidget.startThreads">startThreads</a></code></li>
<li><code><a title="controlunit.main.MainWidget.togglePlots" href="#controlunit.main.MainWidget.togglePlots">togglePlots</a></code></li>
<li><code><a title="controlunit.main.MainWidget.updateIGmode" href="#controlunit.main.MainWidget.updateIGmode">updateIGmode</a></code></li>
<li><code><a title="controlunit.main.MainWidget.updateIGrange" href="#controlunit.main.MainWidget.updateIGrange">updateIGrange</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="controlunit.main.pigpio" href="#controlunit.main.pigpio">pigpio</a></code></h4>
<ul class="">
<li><code><a title="controlunit.main.pigpio.pi" href="#controlunit.main.pigpio.pi">pi</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>